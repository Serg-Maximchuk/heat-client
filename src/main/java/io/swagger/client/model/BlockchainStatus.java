/*
 * HEAT API
 * The HEAT <u><b>INTERACTIVE</b></u> REST API, 
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * Blockchain Status class
 */
@Schema(description = "Blockchain Status class")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-04-28T22:39:51.557155300+03:00[Europe/Helsinki]")
public class BlockchainStatus {
  @SerializedName("isScanning")
  private Boolean isScanning = false;

  @SerializedName("cumulativeDifficulty")
  private String cumulativeDifficulty = null;

  @SerializedName("numberOfBlocks")
  private Integer numberOfBlocks = null;

  @SerializedName("numberOfTransactions")
  private Integer numberOfTransactions = null;

  @SerializedName("numberOfUnconfirmedTransactions")
  private Integer numberOfUnconfirmedTransactions = null;

  @SerializedName("version")
  private String version = null;

  @SerializedName("lastBlock")
  private String lastBlock = null;

  @SerializedName("lastBlockTimestamp")
  private Integer lastBlockTimestamp = null;

  @SerializedName("application")
  private String application = null;

  @SerializedName("lastBlockchainFeederHeight")
  private Integer lastBlockchainFeederHeight = null;

  @SerializedName("time")
  private Integer time = null;

  @SerializedName("lastBlockchainFeeder")
  private String lastBlockchainFeeder = null;

  @SerializedName("initialCoinSupply")
  private String initialCoinSupply = null;

  @SerializedName("currentCoinSupply")
  private String currentCoinSupply = null;

  public BlockchainStatus isScanning(Boolean isScanning) {
    this.isScanning = isScanning;
    return this;
  }

   /**
   * True if this node is scanning the blockchain, false otherwise
   * @return isScanning
  **/
  @Schema(description = "True if this node is scanning the blockchain, false otherwise")
  public Boolean isIsScanning() {
    return isScanning;
  }

  public void setIsScanning(Boolean isScanning) {
    this.isScanning = isScanning;
  }

  public BlockchainStatus cumulativeDifficulty(String cumulativeDifficulty) {
    this.cumulativeDifficulty = cumulativeDifficulty;
    return this;
  }

   /**
   * The current cumulative miner difficulty
   * @return cumulativeDifficulty
  **/
  @Schema(description = "The current cumulative miner difficulty")
  public String getCumulativeDifficulty() {
    return cumulativeDifficulty;
  }

  public void setCumulativeDifficulty(String cumulativeDifficulty) {
    this.cumulativeDifficulty = cumulativeDifficulty;
  }

  public BlockchainStatus numberOfBlocks(Integer numberOfBlocks) {
    this.numberOfBlocks = numberOfBlocks;
    return this;
  }

   /**
   * The number of blocks (height + 1) in the blockchain
   * @return numberOfBlocks
  **/
  @Schema(description = "The number of blocks (height + 1) in the blockchain")
  public Integer getNumberOfBlocks() {
    return numberOfBlocks;
  }

  public void setNumberOfBlocks(Integer numberOfBlocks) {
    this.numberOfBlocks = numberOfBlocks;
  }

  public BlockchainStatus numberOfTransactions(Integer numberOfTransactions) {
    this.numberOfTransactions = numberOfTransactions;
    return this;
  }

   /**
   * The number of transactions in the blockchain
   * @return numberOfTransactions
  **/
  @Schema(description = "The number of transactions in the blockchain")
  public Integer getNumberOfTransactions() {
    return numberOfTransactions;
  }

  public void setNumberOfTransactions(Integer numberOfTransactions) {
    this.numberOfTransactions = numberOfTransactions;
  }

  public BlockchainStatus numberOfUnconfirmedTransactions(Integer numberOfUnconfirmedTransactions) {
    this.numberOfUnconfirmedTransactions = numberOfUnconfirmedTransactions;
    return this;
  }

   /**
   * The number of unconfirmed transactions
   * @return numberOfUnconfirmedTransactions
  **/
  @Schema(description = "The number of unconfirmed transactions")
  public Integer getNumberOfUnconfirmedTransactions() {
    return numberOfUnconfirmedTransactions;
  }

  public void setNumberOfUnconfirmedTransactions(Integer numberOfUnconfirmedTransactions) {
    this.numberOfUnconfirmedTransactions = numberOfUnconfirmedTransactions;
  }

  public BlockchainStatus version(String version) {
    this.version = version;
    return this;
  }

   /**
   * The software version on this node
   * @return version
  **/
  @Schema(description = "The software version on this node")
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }

  public BlockchainStatus lastBlock(String lastBlock) {
    this.lastBlock = lastBlock;
    return this;
  }

   /**
   * The last block numeric id
   * @return lastBlock
  **/
  @Schema(description = "The last block numeric id")
  public String getLastBlock() {
    return lastBlock;
  }

  public void setLastBlock(String lastBlock) {
    this.lastBlock = lastBlock;
  }

  public BlockchainStatus lastBlockTimestamp(Integer lastBlockTimestamp) {
    this.lastBlockTimestamp = lastBlockTimestamp;
    return this;
  }

   /**
   * Timestamp of the last block
   * @return lastBlockTimestamp
  **/
  @Schema(description = "Timestamp of the last block")
  public Integer getLastBlockTimestamp() {
    return lastBlockTimestamp;
  }

  public void setLastBlockTimestamp(Integer lastBlockTimestamp) {
    this.lastBlockTimestamp = lastBlockTimestamp;
  }

  public BlockchainStatus application(String application) {
    this.application = application;
    return this;
  }

   /**
   * The name of the software running on this node
   * @return application
  **/
  @Schema(description = "The name of the software running on this node")
  public String getApplication() {
    return application;
  }

  public void setApplication(String application) {
    this.application = application;
  }

  public BlockchainStatus lastBlockchainFeederHeight(Integer lastBlockchainFeederHeight) {
    this.lastBlockchainFeederHeight = lastBlockchainFeederHeight;
    return this;
  }

   /**
   * The height of the last blockchain feeder
   * @return lastBlockchainFeederHeight
  **/
  @Schema(description = "The height of the last blockchain feeder")
  public Integer getLastBlockchainFeederHeight() {
    return lastBlockchainFeederHeight;
  }

  public void setLastBlockchainFeederHeight(Integer lastBlockchainFeederHeight) {
    this.lastBlockchainFeederHeight = lastBlockchainFeederHeight;
  }

  public BlockchainStatus time(Integer time) {
    this.time = time;
    return this;
  }

   /**
   * The current node time (in seconds since 24 november 2013 00:00 UTC)
   * @return time
  **/
  @Schema(description = "The current node time (in seconds since 24 november 2013 00:00 UTC)")
  public Integer getTime() {
    return time;
  }

  public void setTime(Integer time) {
    this.time = time;
  }

  public BlockchainStatus lastBlockchainFeeder(String lastBlockchainFeeder) {
    this.lastBlockchainFeeder = lastBlockchainFeeder;
    return this;
  }

   /**
   * The announced name of the feeder of the last blockchain
   * @return lastBlockchainFeeder
  **/
  @Schema(description = "The announced name of the feeder of the last blockchain")
  public String getLastBlockchainFeeder() {
    return lastBlockchainFeeder;
  }

  public void setLastBlockchainFeeder(String lastBlockchainFeeder) {
    this.lastBlockchainFeeder = lastBlockchainFeeder;
  }

  public BlockchainStatus initialCoinSupply(String initialCoinSupply) {
    this.initialCoinSupply = initialCoinSupply;
    return this;
  }

   /**
   * Amount of HEAT in genesis block (in HQT, 1 HQT is 0.00000001 HEAT)
   * @return initialCoinSupply
  **/
  @Schema(description = "Amount of HEAT in genesis block (in HQT, 1 HQT is 0.00000001 HEAT)")
  public String getInitialCoinSupply() {
    return initialCoinSupply;
  }

  public void setInitialCoinSupply(String initialCoinSupply) {
    this.initialCoinSupply = initialCoinSupply;
  }

  public BlockchainStatus currentCoinSupply(String currentCoinSupply) {
    this.currentCoinSupply = currentCoinSupply;
    return this;
  }

   /**
   * Current total amount of HEAT (in HQT, 1 HQT is 0.00000001 HEAT)
   * @return currentCoinSupply
  **/
  @Schema(description = "Current total amount of HEAT (in HQT, 1 HQT is 0.00000001 HEAT)")
  public String getCurrentCoinSupply() {
    return currentCoinSupply;
  }

  public void setCurrentCoinSupply(String currentCoinSupply) {
    this.currentCoinSupply = currentCoinSupply;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BlockchainStatus blockchainStatus = (BlockchainStatus) o;
    return Objects.equals(this.isScanning, blockchainStatus.isScanning) &&
        Objects.equals(this.cumulativeDifficulty, blockchainStatus.cumulativeDifficulty) &&
        Objects.equals(this.numberOfBlocks, blockchainStatus.numberOfBlocks) &&
        Objects.equals(this.numberOfTransactions, blockchainStatus.numberOfTransactions) &&
        Objects.equals(this.numberOfUnconfirmedTransactions, blockchainStatus.numberOfUnconfirmedTransactions) &&
        Objects.equals(this.version, blockchainStatus.version) &&
        Objects.equals(this.lastBlock, blockchainStatus.lastBlock) &&
        Objects.equals(this.lastBlockTimestamp, blockchainStatus.lastBlockTimestamp) &&
        Objects.equals(this.application, blockchainStatus.application) &&
        Objects.equals(this.lastBlockchainFeederHeight, blockchainStatus.lastBlockchainFeederHeight) &&
        Objects.equals(this.time, blockchainStatus.time) &&
        Objects.equals(this.lastBlockchainFeeder, blockchainStatus.lastBlockchainFeeder) &&
        Objects.equals(this.initialCoinSupply, blockchainStatus.initialCoinSupply) &&
        Objects.equals(this.currentCoinSupply, blockchainStatus.currentCoinSupply);
  }

  @Override
  public int hashCode() {
    return Objects.hash(isScanning, cumulativeDifficulty, numberOfBlocks, numberOfTransactions, numberOfUnconfirmedTransactions, version, lastBlock, lastBlockTimestamp, application, lastBlockchainFeederHeight, time, lastBlockchainFeeder, initialCoinSupply, currentCoinSupply);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BlockchainStatus {\n");
    
    sb.append("    isScanning: ").append(toIndentedString(isScanning)).append("\n");
    sb.append("    cumulativeDifficulty: ").append(toIndentedString(cumulativeDifficulty)).append("\n");
    sb.append("    numberOfBlocks: ").append(toIndentedString(numberOfBlocks)).append("\n");
    sb.append("    numberOfTransactions: ").append(toIndentedString(numberOfTransactions)).append("\n");
    sb.append("    numberOfUnconfirmedTransactions: ").append(toIndentedString(numberOfUnconfirmedTransactions)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    lastBlock: ").append(toIndentedString(lastBlock)).append("\n");
    sb.append("    lastBlockTimestamp: ").append(toIndentedString(lastBlockTimestamp)).append("\n");
    sb.append("    application: ").append(toIndentedString(application)).append("\n");
    sb.append("    lastBlockchainFeederHeight: ").append(toIndentedString(lastBlockchainFeederHeight)).append("\n");
    sb.append("    time: ").append(toIndentedString(time)).append("\n");
    sb.append("    lastBlockchainFeeder: ").append(toIndentedString(lastBlockchainFeeder)).append("\n");
    sb.append("    initialCoinSupply: ").append(toIndentedString(initialCoinSupply)).append("\n");
    sb.append("    currentCoinSupply: ").append(toIndentedString(currentCoinSupply)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
