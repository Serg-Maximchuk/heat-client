/*
 * HEAT API
 * The HEAT <u><b>INTERACTIVE</b></u> REST API, 
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * Order class
 */
@Schema(description = "Order class")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-04-28T22:39:51.557155300+03:00[Europe/Helsinki]")
public class Order {
  @SerializedName("order")
  private String order = null;

  @SerializedName("currency")
  private String currency = null;

  @SerializedName("asset")
  private String asset = null;

  @SerializedName("account")
  private String account = null;

  @SerializedName("accountName")
  private String accountName = null;

  @SerializedName("quantity")
  private String quantity = null;

  @SerializedName("unconfirmedQuantity")
  private String unconfirmedQuantity = null;

  @SerializedName("price")
  private String price = null;

  @SerializedName("height")
  private Integer height = null;

  @SerializedName("transactionIndex")
  private Integer transactionIndex = null;

  /**
   * Order type, either &#x60;ask&#x60; or &#x60;bid&#x60;
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    ASK("ask"),
    BID("bid");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = null;

  @SerializedName("cancelled")
  private Boolean cancelled = false;

  @SerializedName("unconfirmed")
  private Boolean unconfirmed = false;

  @SerializedName("expiration")
  private Integer expiration = null;

  @SerializedName("currentlyNotValid")
  private Boolean currentlyNotValid = false;

  public Order order(String order) {
    this.order = order;
    return this;
  }

   /**
   * The ID of the order
   * @return order
  **/
  @Schema(required = true, description = "The ID of the order")
  public String getOrder() {
    return order;
  }

  public void setOrder(String order) {
    this.order = order;
  }

  public Order currency(String currency) {
    this.currency = currency;
    return this;
  }

   /**
   * The ID of the currency with which we are paying (BID order) or which we will be receiving (ASK order)
   * @return currency
  **/
  @Schema(required = true, description = "The ID of the currency with which we are paying (BID order) or which we will be receiving (ASK order)")
  public String getCurrency() {
    return currency;
  }

  public void setCurrency(String currency) {
    this.currency = currency;
  }

  public Order asset(String asset) {
    this.asset = asset;
    return this;
  }

   /**
   * The ID of the asset being bought or sold
   * @return asset
  **/
  @Schema(required = true, description = "The ID of the asset being bought or sold")
  public String getAsset() {
    return asset;
  }

  public void setAsset(String asset) {
    this.asset = asset;
  }

  public Order account(String account) {
    this.account = account;
    return this;
  }

   /**
   * The account number associated with the order
   * @return account
  **/
  @Schema(required = true, description = "The account number associated with the order")
  public String getAccount() {
    return account;
  }

  public void setAccount(String account) {
    this.account = account;
  }

  public Order accountName(String accountName) {
    this.accountName = accountName;
    return this;
  }

   /**
   * The account name associated with the order
   * @return accountName
  **/
  @Schema(description = "The account name associated with the order")
  public String getAccountName() {
    return accountName;
  }

  public void setAccountName(String accountName) {
    this.accountName = accountName;
  }

  public Order quantity(String quantity) {
    this.quantity = quantity;
    return this;
  }

   /**
   * The order quantity (in QNT)
   * @return quantity
  **/
  @Schema(required = true, description = "The order quantity (in QNT)")
  public String getQuantity() {
    return quantity;
  }

  public void setQuantity(String quantity) {
    this.quantity = quantity;
  }

  public Order unconfirmedQuantity(String unconfirmedQuantity) {
    this.unconfirmedQuantity = unconfirmedQuantity;
    return this;
  }

   /**
   * the unconfirmed order quantity (in QNT)
   * @return unconfirmedQuantity
  **/
  @Schema(required = true, description = "the unconfirmed order quantity (in QNT)")
  public String getUnconfirmedQuantity() {
    return unconfirmedQuantity;
  }

  public void setUnconfirmedQuantity(String unconfirmedQuantity) {
    this.unconfirmedQuantity = unconfirmedQuantity;
  }

  public Order price(String price) {
    this.price = price;
    return this;
  }

   /**
   * The order price (given in currency units, could be either HQT if currency is HEAT or QNT if currency is an asset)
   * @return price
  **/
  @Schema(required = true, description = "The order price (given in currency units, could be either HQT if currency is HEAT or QNT if currency is an asset)")
  public String getPrice() {
    return price;
  }

  public void setPrice(String price) {
    this.price = price;
  }

  public Order height(Integer height) {
    this.height = height;
    return this;
  }

   /**
   * The block height of the order transaction
   * @return height
  **/
  @Schema(required = true, description = "The block height of the order transaction")
  public Integer getHeight() {
    return height;
  }

  public void setHeight(Integer height) {
    this.height = height;
  }

  public Order transactionIndex(Integer transactionIndex) {
    this.transactionIndex = transactionIndex;
    return this;
  }

   /**
   * A zero-based index giving the order of the transaction in its block
   * @return transactionIndex
  **/
  @Schema(required = true, description = "A zero-based index giving the order of the transaction in its block")
  public Integer getTransactionIndex() {
    return transactionIndex;
  }

  public void setTransactionIndex(Integer transactionIndex) {
    this.transactionIndex = transactionIndex;
  }

  public Order type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Order type, either &#x60;ask&#x60; or &#x60;bid&#x60;
   * @return type
  **/
  @Schema(required = true, description = "Order type, either `ask` or `bid`")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public Order cancelled(Boolean cancelled) {
    this.cancelled = cancelled;
    return this;
  }

   /**
   * Indicates an unconfirmed cancellation is pending
   * @return cancelled
  **/
  @Schema(required = true, description = "Indicates an unconfirmed cancellation is pending")
  public Boolean isCancelled() {
    return cancelled;
  }

  public void setCancelled(Boolean cancelled) {
    this.cancelled = cancelled;
  }

  public Order unconfirmed(Boolean unconfirmed) {
    this.unconfirmed = unconfirmed;
    return this;
  }

   /**
   * This is an unconfirmed or pending order
   * @return unconfirmed
  **/
  @Schema(required = true, description = "This is an unconfirmed or pending order")
  public Boolean isUnconfirmed() {
    return unconfirmed;
  }

  public void setUnconfirmed(Boolean unconfirmed) {
    this.unconfirmed = unconfirmed;
  }

  public Order expiration(Integer expiration) {
    this.expiration = expiration;
    return this;
  }

   /**
   * The expiration time (in seconds since 24 november 2013 00:00 UTC)
   * @return expiration
  **/
  @Schema(required = true, description = "The expiration time (in seconds since 24 november 2013 00:00 UTC)")
  public Integer getExpiration() {
    return expiration;
  }

  public void setExpiration(Integer expiration) {
    this.expiration = expiration;
  }

  public Order currentlyNotValid(Boolean currentlyNotValid) {
    this.currentlyNotValid = currentlyNotValid;
    return this;
  }

   /**
   * Order is currently not valid, but might become valid in the future
   * @return currentlyNotValid
  **/
  @Schema(required = true, description = "Order is currently not valid, but might become valid in the future")
  public Boolean isCurrentlyNotValid() {
    return currentlyNotValid;
  }

  public void setCurrentlyNotValid(Boolean currentlyNotValid) {
    this.currentlyNotValid = currentlyNotValid;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Order order = (Order) o;
    return Objects.equals(this.order, order.order) &&
        Objects.equals(this.currency, order.currency) &&
        Objects.equals(this.asset, order.asset) &&
        Objects.equals(this.account, order.account) &&
        Objects.equals(this.accountName, order.accountName) &&
        Objects.equals(this.quantity, order.quantity) &&
        Objects.equals(this.unconfirmedQuantity, order.unconfirmedQuantity) &&
        Objects.equals(this.price, order.price) &&
        Objects.equals(this.height, order.height) &&
        Objects.equals(this.transactionIndex, order.transactionIndex) &&
        Objects.equals(this.type, order.type) &&
        Objects.equals(this.cancelled, order.cancelled) &&
        Objects.equals(this.unconfirmed, order.unconfirmed) &&
        Objects.equals(this.expiration, order.expiration) &&
        Objects.equals(this.currentlyNotValid, order.currentlyNotValid);
  }

  @Override
  public int hashCode() {
    return Objects.hash(order, currency, asset, account, accountName, quantity, unconfirmedQuantity, price, height, transactionIndex, type, cancelled, unconfirmed, expiration, currentlyNotValid);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Order {\n");
    
    sb.append("    order: ").append(toIndentedString(order)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    asset: ").append(toIndentedString(asset)).append("\n");
    sb.append("    account: ").append(toIndentedString(account)).append("\n");
    sb.append("    accountName: ").append(toIndentedString(accountName)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    unconfirmedQuantity: ").append(toIndentedString(unconfirmedQuantity)).append("\n");
    sb.append("    price: ").append(toIndentedString(price)).append("\n");
    sb.append("    height: ").append(toIndentedString(height)).append("\n");
    sb.append("    transactionIndex: ").append(toIndentedString(transactionIndex)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    cancelled: ").append(toIndentedString(cancelled)).append("\n");
    sb.append("    unconfirmed: ").append(toIndentedString(unconfirmed)).append("\n");
    sb.append("    expiration: ").append(toIndentedString(expiration)).append("\n");
    sb.append("    currentlyNotValid: ").append(toIndentedString(currentlyNotValid)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
